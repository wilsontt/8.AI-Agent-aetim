# 週報排程觸發與通知發送流程說明

## 文件資訊

**專案名稱**：AI 驅動之自動化威脅情資管理系統 (AETIM)  
**文件版本**：v1.0  
**建立日期**：2025年11月  
**文件目的**：說明週報排程從設定時間觸發到最終發送通知郵件的完整流程

---

## 目錄

1. [流程概述](#流程概述)
2. [詳細流程說明](#詳細流程說明)
3. [關鍵程式碼位置](#關鍵程式碼位置)
4. [流程圖](#流程圖)
5. [相關設定檔](#相關設定檔)

---

## 流程概述

當週報排程設定（CISO 週報）的設定時間到達時，系統會自動執行以下流程：

1. **排程註冊**：APScheduler 註冊週報生成任務
2. **排程觸發**：APScheduler 在設定時間觸發任務
3. **報告生成**：生成 CISO 週報和/或 IT 工單報告
4. **通知處理**：調用通知處理器準備郵件內容
5. **郵件發送**：通過 SMTP 發送郵件

---

## 詳細流程說明

### 階段 1：排程註冊（`aetim/scheduler.py`）

**函數**：`reschedule_weekly_report(scheduler)`  
**位置**：約第 307-318 行

當系統啟動或重新載入排程時，會將週報生成任務註冊到 APScheduler：

```python
trigger = CronTrigger(
    day_of_week=day,      # 例如：'wed'
    hour=hour,            # 例如：15
    minute=minute,        # 例如：10
    timezone="Asia/Taipei"
)

scheduler.add_job(
    generate_weekly_report_job,  # ← 註冊的任務函數
    trigger=trigger,
    id="job_weekly_report",
    replace_existing=True,
    max_instances=1  # 確保同一時間只有一個實例運行
)
```

**關鍵點**：
- 使用 `CronTrigger` 設定每週特定時間執行
- 固定使用 `Asia/Taipei` 時區
- 任務 ID 為 `job_weekly_report`

---

### 階段 2：排程觸發（`aetim/scheduler.py`）

**函數**：`generate_weekly_report_job()`  
**位置**：第 86 行開始

當 APScheduler 在設定時間觸發時，會執行此函數：

#### 2.1 初始化與檢查（第 86-133 行）

```python
def generate_weekly_report_job():
    """週報生成任務"""
    # 記錄觸發時間
    trigger_time = datetime.now(taipei_tz)
    print(f"[週報] 排程觸發時間：{trigger_time.isoformat()}")
    
    # 建立事件記錄
    ev = start_event({'phase': 'scheduled', 'message': '週報排程已觸發'})
    
    # 檢查週報通知是否啟用
    weekly_enabled = weekly_cfg.get('enabled', True)
    email_enabled = notification_config.get('email', {}).get('enabled', False)
    
    if not weekly_enabled or not email_enabled:
        # 如果未啟用，跳過執行
        return
```

#### 2.2 取得收件者列表（第 139-167 行）

```python
# 從設定檔讀取收件者
rec_groups = weekly_cfg.get('recipients', [])  # 例如：['ciso', 'it']
recipients_map = notification_config.get('recipients', {})
target_emails = []
recipient_types = {}  # {email: ['ciso', 'it']}

for g in rec_groups:
    addr = recipients_map.get(g)
    if addr:
        target_emails.append(addr)
        recipient_types[addr].append(g)
```

#### 2.3 生成報告（第 169-227 行）

```python
# 決定需要生成哪些報告
needs_ciso_report = any('ciso' in recipient_types.get(addr, []) for addr in target_emails)
needs_it_tickets = any('it' in recipient_types.get(addr, []) for addr in target_emails)

# 生成 CISO 週報（如果需要）
if needs_ciso_report:
    report_data = reporting_engine.generate_weekly_report(db_conn, cfg)
    ciso_report_filepath = reporting_engine.save_report(
        report_data, 'ciso_weekly', 'html'
    )

# 生成 IT 工單（如果需要）
if needs_it_tickets:
    it_tickets = reporting_engine.generate_it_tickets_for_high_risk(
        db_conn, cfg, risk_threshold=7.0
    )
    it_report_filepath = reporting_engine.save_report(
        it_report_data, 'it_ticket', 'json'
    )
```

---

### 階段 3：通知發送（`aetim/scheduler.py`）

**位置**：第 229-280 行

在報告生成完成後，開始發送通知：

```python
# 更新事件狀態
update_event(ev['id'], {'phase': 'notify', 'message': '開始發送週報通知'})

# 根據收件者類型發送對應的報告
for addr in target_emails:
    addr_types = recipient_types.get(addr, [])
    
    # 發送 CISO 週報
    if 'ciso' in addr_types and ciso_report_filepath:
        print(f"[週報] 發送 CISO 週報至：{addr}")
        notification_handler.notify_weekly_report(
            ciso_report_filepath, 
            cfg, 
            target_email=addr
        )  # ← 關鍵觸發點 1
    
    # 發送 IT 工單報告
    if 'it' in addr_types and it_report_filepath:
        print(f"[週報] 發送 IT 工單報告至：{addr}")
        notification_handler.notify_it_tickets(
            it_report_filepath, 
            cfg, 
            target_email=addr
        )  # ← 關鍵觸發點 2
```

**關鍵觸發點**：
- **第 246 行**：調用 `notification_handler.notify_weekly_report()` 發送 CISO 週報
- **第 251 行**：調用 `notification_handler.notify_it_tickets()` 發送 IT 工單報告

---

### 階段 4：通知處理（`aetim/notification_handler.py`）

**函數**：`notify_weekly_report(report_filepath, config, target_email=None)`  
**位置**：第 367 行開始

#### 4.1 檢查設定（第 380-408 行）

```python
def notify_weekly_report(report_filepath: str, config: Dict, target_email: str = None):
    """工作流 3：管理層週報（Weekly Report）- 排程"""
    
    # 檢查通知功能是否啟用
    notification_enabled = notification_config.get('enabled', False)
    email_enabled = email_config.get('enabled', False)
    
    if not email_enabled:
        print("[通知] Email 功能未啟用，跳過週報發送。")
        return
```

#### 4.2 決定收件者（第 410-434 行）

```python
# 如果指定了收件者，直接使用
if target_email:
    target_emails = [target_email]
else:
    # 否則從設定檔讀取
    target_emails = []
    rec_groups = weekly_cfg.get('recipients', [])
    recipients_map = notification_config.get('recipients', {})
    for g in rec_groups:
        addr = recipients_map.get(g)
        if addr:
            target_emails.append(addr)
```

#### 4.3 準備郵件內容（第 436-467 行）

```python
# 驗證必要的 SMTP 設定
smtp_server = email_config.get('smtp_server', '')
smtp_port = email_config.get('smtp_port', 587)
smtp_username = email_config.get('smtp_username', '')
smtp_password = email_config.get('smtp_password', '')
from_address = email_config.get('from_address', '')

# 建立郵件主旨
subject = f"[AETIM 資安情資週報] {get_taipei_time().strftime('%Y-%m-%d')}"

# 讀取報告內容
if report_filepath and os.path.exists(report_filepath):
    with open(report_filepath, 'r', encoding='utf-8') as f:
        body = f.read()
    attachments = [report_filepath]
```

#### 4.4 調用發送函數（約第 467 行）

```python
# 最終調用 send_email() 發送郵件
send_email(
    subject=subject,
    body=body,
    to_address=target_email,
    from_address=from_address,
    smtp_server=smtp_server,
    smtp_port=smtp_port,
    smtp_username=smtp_username,
    smtp_password=smtp_password,
    use_tls=email_config.get('use_tls', True),
    attachments=attachments
)  # ← 關鍵觸發點 3
```

---

### 階段 5：實際發送郵件（`aetim/notification_handler.py`）

**函數**：`send_email(...)`  
**位置**：第 28 行開始

#### 5.1 建立郵件物件（第 64-88 行）

```python
def send_email(subject: str, body: str, to_address: str, from_address: str, 
               smtp_server: str, smtp_port: int, smtp_username: str, 
               smtp_password: str, use_tls: bool = True, attachments: List[str] = None):
    """發送 Email"""
    
    # 建立郵件物件
    msg = MIMEMultipart('alternative')
    msg['From'] = from_address
    msg['To'] = to_address
    msg['Subject'] = subject
    
    # 判斷是否為 HTML
    if '<html>' in body.lower() or '<body>' in body.lower():
        msg.attach(MIMEText(body, 'html', 'utf-8'))
    else:
        msg.attach(MIMEText(body, 'plain', 'utf-8'))
    
    # 添加附件
    if attachments:
        for filepath in attachments:
            # ... 添加附件邏輯 ...
```

#### 5.2 連接 SMTP 並發送（第 90-108 行）

```python
    # 連接 SMTP 伺服器
    server = smtplib.SMTP(smtp_server, smtp_port, timeout=30)
    
    if use_tls:
        server.starttls()
    
    if smtp_username and smtp_password:
        server.login(smtp_username, smtp_password)
    
    # 發送郵件
    server.send_message(msg)  # ← 關鍵觸發點 4：實際發送
    server.quit()
    
    print(f"[通知] Email 已成功發送至：{to_address}")
    return True
```

---

## 關鍵程式碼位置

### 完整呼叫鏈

```
1. scheduler.py: reschedule_weekly_report() (第 307-318 行)
   └─ 註冊任務到 APScheduler
      │
      ├─ scheduler.add_job(generate_weekly_report_job, ...)
      │
      ▼
2. scheduler.py: generate_weekly_report_job() (第 86 行開始)
   └─ APScheduler 觸發執行
      │
      ├─ 生成報告 (第 176-218 行)
      │  ├─ reporting_engine.generate_weekly_report()
      │  └─ reporting_engine.save_report()
      │
      └─ 發送通知 (第 229-280 行)
         │
         ├─ notification_handler.notify_weekly_report()  ← 第 246 行
         │  │
         │  └─ notification_handler.py: notify_weekly_report() (第 367 行)
         │     │
         │     └─ send_email()  ← 約第 467 行
         │        │
         │        └─ notification_handler.py: send_email() (第 28 行)
         │           │
         │           └─ smtplib.SMTP.send_message()  ← 第 104 行
         │
         └─ notification_handler.notify_it_tickets()  ← 第 251 行
            │
            └─ (類似流程)
```

### 關鍵觸發點總結

| 階段 | 檔案 | 函數/位置 | 說明 |
|------|------|-----------|------|
| 1. 註冊 | `scheduler.py` | `reschedule_weekly_report()` (第 307-318 行) | 註冊任務到 APScheduler |
| 2. 觸發 | `scheduler.py` | `generate_weekly_report_job()` (第 86 行) | APScheduler 觸發執行 |
| 3. 通知 | `scheduler.py` | 第 246 行 | 調用 `notify_weekly_report()` |
| 4. 處理 | `notification_handler.py` | `notify_weekly_report()` (第 367 行) | 準備郵件內容 |
| 5. 發送 | `notification_handler.py` | `send_email()` (第 28 行) | 實際發送郵件 |
| 6. SMTP | `notification_handler.py` | 第 104 行 | `smtplib.SMTP.send_message()` |

---

## 流程圖

```
┌─────────────────────────────────────────────────────────────┐
│                   週報排程觸發與通知發送流程                    │
└─────────────────────────────────────────────────────────────┘

1. 排程註冊階段
   ┌─────────────────────┐
   │ reschedule_weekly_  │
   │ report()            │
   │ (scheduler.py)      │
   └──────────┬──────────┘
              │
              ▼
   ┌─────────────────────┐
   │ scheduler.add_job() │
   │ 註冊任務到 APScheduler│
   └─────────────────────┘

2. 排程觸發階段
   ┌─────────────────────┐
   │ APScheduler 觸發     │
   │ (設定時間到達)       │
   └──────────┬──────────┘
              │
              ▼
   ┌─────────────────────┐
   │ generate_weekly_    │
   │ report_job()        │
   │ (scheduler.py:86)    │
   └──────────┬──────────┘
              │
              ├─────────────────┐
              │                 │
              ▼                 ▼
   ┌──────────────────┐  ┌──────────────────┐
   │ 生成 CISO 週報    │  │ 生成 IT 工單     │
   │ (reporting_engine)│  │ (reporting_engine)│
   └──────────────────┘  └──────────────────┘
              │                 │
              └────────┬────────┘
                       │
                       ▼
   ┌─────────────────────┐
   │ 更新事件狀態         │
   │ phase: 'notify'      │
   └──────────┬──────────┘

3. 通知發送階段
              │
              ▼
   ┌─────────────────────┐
   │ notify_weekly_report │
   │ (scheduler.py:246)  │
   └──────────┬──────────┘
              │
              ▼
   ┌─────────────────────┐
   │ notify_weekly_report│
   │ (notification_      │
   │  handler.py:367)    │
   └──────────┬──────────┘
              │
              ├─────────────────┐
              │                 │
              ▼                 ▼
   ┌──────────────────┐  ┌──────────────────┐
   │ 檢查設定         │  │ 準備郵件內容      │
   │ (email.enabled)  │  │ (讀取報告檔案)    │
   └──────────────────┘  └──────────────────┘
              │                 │
              └────────┬────────┘
                       │
                       ▼
   ┌─────────────────────┐
   │ send_email()         │
   │ (notification_       │
   │  handler.py:28)      │
   └──────────┬──────────┘

4. 實際發送階段
              │
              ▼
   ┌─────────────────────┐
   │ 建立郵件物件        │
   │ (MIMEMultipart)     │
   └──────────┬──────────┘
              │
              ▼
   ┌─────────────────────┐
   │ 連接 SMTP 伺服器    │
   │ (smtplib.SMTP)      │
   └──────────┬──────────┘
              │
              ▼
   ┌─────────────────────┐
   │ server.send_message()│
   │ (實際發送郵件)       │
   └─────────────────────┘
              │
              ▼
   ┌─────────────────────┐
   │ 更新事件狀態         │
   │ phase: 'done'        │
   │ status: 'success'    │
   └─────────────────────┘
```

---

## 相關設定檔

### 排程設定（`aetim/config.yaml`）

```yaml
reporting:
  weekly_report:
    enabled: true
    schedule_struct:
      day_of_week: wed      # 星期幾
      hour: 15              # 小時
      minute: 10            # 分鐘
      timezone: Asia/Taipei # 時區
```

### 通知設定（`aetim/config.yaml`）

```yaml
notification:
  enabled: true
  email:
    enabled: true
    smtp_server: "smtp.example.com"
    smtp_port: 587
    smtp_username: "user@example.com"
    smtp_password: "password"
    from_address: "aetim@example.com"
    use_tls: true
  types:
    weekly_report:
      enabled: true
      recipients: ['ciso', 'it']  # 收件者群組
  recipients:
    ciso: "ciso@example.com"
    it: "it@example.com"
```

---

## 注意事項

1. **時區設定**：所有時間相關操作都使用 `Asia/Taipei` 時區
2. **錯誤處理**：每個階段都有錯誤處理機制，失敗時會記錄到事件系統
3. **並發控制**：使用 `max_instances=1` 確保同一時間只有一個實例運行
4. **設定檢查**：發送前會檢查 `email.enabled` 和 `weekly_report.enabled`
5. **收件者決定**：優先使用函數參數 `target_email`，否則從設定檔讀取

---

## 除錯建議

如果週報未正常發送，請檢查：

1. **排程是否註冊**：查看 `scheduler.out` 日誌，確認任務已註冊
2. **時間是否到達**：使用 Web 界面的「檢查排程狀態」功能
3. **設定是否啟用**：確認 `notification.email.enabled` 和 `notification.types.weekly_report.enabled` 為 `true`
4. **SMTP 設定**：確認 SMTP 伺服器、帳號、密碼正確
5. **事件記錄**：查看資料庫中的 `T_Job_Events` 表，確認事件狀態

---

## 版本歷史

- **v1.0** (2025-11)：初始版本，說明完整流程

