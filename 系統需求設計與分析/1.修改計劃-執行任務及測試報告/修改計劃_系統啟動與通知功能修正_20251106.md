# AETIM 系統啟動與通知功能修正計劃

**日期：** 2025年11月06日  
**版本：** v2.0  
**狀態：** 計劃中

---

## 1. 問題概述

根據使用者反饋，系統需要進行以下修正：

### 1.1 最高原則問題
- **問題 1.1**：電腦啟動後，Docker 需要自動啟動，aetim 容器服務也要自動啟動
- **問題 1.2**：服務正常啟動後，排程狀態為啟動（預設），需要立即觸發全部（收集+分析），然後產生 CISO 報告
- **問題 1.3**：Docker 時區設定需要在 Asia/Taipei UTC+8
- **問題 1.4**：不管自動執行或手動觸發，都要在處理狀態與報告中顯示訊息

### 1.2 下次執行時間規則問題
- **問題 2.1**：服務正常啟動後，排程狀態為啟動（預設），下次執行時間即開始倒數

### 1.3 處理狀態與報告問題
- **問題 3.1**：報告生成的報告類型（2種）和通知類型的3種類型不一樣，需要釐清

### 1.4 通知處理問題
- **問題 4.1**：沒有收到 Email
- **問題 4.2**：沒有地方可以設定收件者的 Email
- **問題 4.3**：當按發送通知後，會跳出一視窗：通知發送任務已啟動，此訊息請增加收件者的 Email

---

## 2. 修改計劃 (Plan)

### 2.1 Docker 自動啟動機制

#### 2.1.1 macOS 自動啟動設定
- **方案**：使用 `launchd` 或 Docker Desktop 的開機自動啟動功能
- **實作**：
  - 確保 Docker Desktop 設定為開機自動啟動
  - 建立 `launchd` plist 檔案，在系統啟動時執行 `docker-compose up -d`
  - 或使用 Docker Desktop 的設定選項

#### 2.1.2 Docker Compose 自動啟動
- **方案**：確保 `restart: unless-stopped` 設定正確
- **實作**：
  - 檢查 `docker-compose.yml` 中的 `restart` 策略
  - 確保兩個服務都設定為 `restart: unless-stopped`

### 2.2 服務啟動後自動執行任務

#### 2.2.1 啟動時自動執行流程
- **流程**：
  1. 服務啟動
  2. 檢查排程狀態（預設為啟動）
  3. 如果排程狀態為啟動，立即執行：
     - 觸發全部（收集+分析）
     - 生成 CISO 報告
  4. 更新處理狀態與報告顯示

#### 2.2.2 實作位置
- **scheduler.py**：在服務啟動時檢查排程狀態，如果啟用則執行任務
- **web_app.py**：在 Web 服務啟動時，如果排程狀態為啟動，觸發任務執行

### 2.3 Docker 時區設定

#### 2.3.1 時區設定方案
- **方案 1**：在 Dockerfile 中設定時區
  ```dockerfile
  ENV TZ=Asia/Taipei
  RUN ln -snf /usr/share/zoneinfo/$TZ /etc/localtime && echo $TZ > /etc/timezone
  ```
- **方案 2**：在 docker-compose.yml 中設定時區
  ```yaml
  environment:
    - TZ=Asia/Taipei
  ```

#### 2.3.2 Python 時區設定
- **APScheduler**：已設定 `timezone="Asia/Taipei"`
- **datetime**：確保使用正確的時區

### 2.4 處理狀態顯示改進

#### 2.4.1 自動執行狀態顯示
- **需求**：所有自動執行的任務都要在「處理狀態與報告」區域顯示
- **實作**：
  - 在 `scheduler.py` 中執行任務時，更新 `web_app.py` 的 `task_status`
  - 或透過 API 通知 Web 服務更新狀態

#### 2.4.2 狀態同步機制
- **方案 1**：使用共享狀態檔案（JSON 檔案）
- **方案 2**：使用資料庫記錄任務狀態
- **方案 3**：Web 服務定期查詢 scheduler 服務的狀態（透過 API）

### 2.5 下次執行時間規則改進

#### 2.5.1 服務啟動後立即開始倒數
- **需求**：服務正常啟動後，如果排程狀態為啟動，立即開始倒數
- **實作**：
  - 在服務啟動時，記錄啟動時間
  - 計算下次執行時間（啟動時間 + 間隔時間）
  - 開始倒數計時

### 2.6 報告類型與通知類型釐清

#### 2.6.1 報告類型（2種）
- **CISO 週報**：管理層週報，包含威脅摘要、風險分析、建議措施
- **IT 工單**：技術層工單，包含具體的威脅資訊、受影響資產、修補建議

#### 2.6.2 通知類型（3種）
- **週報通知**：發送 CISO 週報給管理層
- **嚴重威脅通知**：風險分數 >= 9.0 的威脅，立即通知
- **高風險威脅通知**：風險分數 >= 7.0 的威脅，每日彙總通知

#### 2.6.3 UI 改進
- **需求**：釐清報告類型和通知類型的區別
- **實作**：
  - 在 UI 中明確標示報告類型和通知類型
  - 添加說明文字

### 2.7 通知功能改進

#### 2.7.1 收件者 Email 設定
- **需求**：在 Web 界面中可以設定收件者 Email
- **實作**：
  - 在「通知人員設定」區域添加收件者 Email 輸入欄位
  - 支援多個收件者（CISO、IT 團隊）
  - 設定儲存到 `config.yaml`

#### 2.7.2 通知訊息改進
- **需求**：發送通知後，顯示收件者 Email
- **實作**：
  - 修改通知發送成功訊息
  - 顯示收件者 Email 地址列表

#### 2.7.3 Email 發送問題排查
- **需求**：排查為什麼沒有收到 Email
- **實作**：
  - 檢查 SMTP 設定
  - 添加詳細的錯誤日誌
  - 測試 Email 發送功能
  - 修復 Email 發送問題

---

## 3. 任務清單 (Tasks)

### 3.1 Docker 自動啟動機制

#### Task 1.1: macOS Docker 自動啟動設定
- **檔案**：建立 `launchd` plist 檔案
- **任務**：
  - 建立 `~/Library/LaunchAgents/com.aetim.docker-compose.plist`
  - 設定在系統啟動時執行 `docker-compose up -d`
  - 或提供 Docker Desktop 設定說明
- **預估時間**：1 小時

#### Task 1.2: 驗證 Docker Compose 自動啟動
- **檔案**：`docker-compose.yml`
- **任務**：
  - 確認 `restart: unless-stopped` 設定正確
  - 測試容器重啟後是否自動啟動
- **預估時間**：0.5 小時

### 3.2 服務啟動後自動執行任務

#### Task 2.1: scheduler.py 啟動時自動執行
- **檔案**：`scheduler.py`
- **任務**：
  - 在服務啟動時，檢查排程狀態
  - 如果排程狀態為啟動，立即執行：
    - 觸發全部（收集+分析）
    - 生成 CISO 報告
  - 確保狀態訊息正確顯示
- **預估時間**：2 小時

#### Task 2.2: web_app.py 啟動時自動執行
- **檔案**：`web_app.py`
- **任務**：
  - 在 Web 服務啟動時，檢查排程狀態
  - 如果排程狀態為啟動，觸發任務執行
  - 更新處理狀態顯示
- **預估時間**：2 小時

#### Task 2.3: 狀態同步機制實作
- **檔案**：`scheduler.py`, `web_app.py`
- **任務**：
  - 實作狀態同步機制（共享狀態檔案或資料庫）
  - 確保自動執行的任務狀態能正確顯示在 Web 界面
- **預估時間**：3 小時

### 3.3 Docker 時區設定

#### Task 3.1: Dockerfile 時區設定
- **檔案**：`Dockerfile`
- **任務**：
  - 添加時區設定（Asia/Taipei）
  - 安裝時區資料
  - 設定環境變數
- **預估時間**：0.5 小時

#### Task 3.2: docker-compose.yml 時區設定
- **檔案**：`docker-compose.yml`
- **任務**：
  - 在兩個服務中添加時區環境變數
  - 確保時區設定正確
- **預估時間**：0.5 小時

#### Task 3.3: 時區設定驗證
- **任務**：
  - 測試容器內的時區設定
  - 確認 Python datetime 使用正確時區
  - 確認排程器使用正確時區
- **預估時間**：0.5 小時

### 3.4 下次執行時間規則改進

#### Task 4.1: 服務啟動後立即開始倒數
- **檔案**：`web_app.py`
- **任務**：
  - 在服務啟動時，如果排程狀態為啟動，立即計算下次執行時間
  - 開始倒數計時
  - 確保倒數時間正確顯示
- **預估時間**：1 小時

### 3.5 報告類型與通知類型釐清

#### Task 5.1: UI 說明改進
- **檔案**：`templates/index.html`
- **任務**：
  - 在「報告生成」區域添加說明文字
  - 在「通知處理」區域添加說明文字
  - 明確區分報告類型和通知類型
- **預估時間**：1 小時

### 3.6 通知功能改進

#### Task 6.1: 收件者 Email 設定 UI
- **檔案**：`templates/index.html`
- **任務**：
  - 在「通知人員設定」區域添加收件者 Email 輸入欄位
  - 支援 CISO 和 IT 團隊分別設定
  - 更新設定儲存邏輯
- **預估時間**：2 小時

#### Task 6.2: 通知設定結構變更
- **檔案**：`config.yaml`, `web_app.py`
- **任務**：
  - 修改通知設定結構，支援多收件者
  - 更新設定讀取和儲存邏輯
- **預估時間**：1.5 小時

#### Task 6.3: 通知訊息顯示改進
- **檔案**：`web_app.py`, `templates/index.html`
- **任務**：
  - 修改通知發送成功訊息
  - 顯示收件者 Email 地址列表
- **預估時間**：1 小時

#### Task 6.4: Email 發送問題排查
- **檔案**：`notification_handler.py`
- **任務**：
  - 檢查 SMTP 設定和連線
  - 添加詳細的錯誤日誌
  - 測試 Email 發送功能
  - 修復 Email 發送問題
- **預估時間**：3 小時

---

## 4. 實施順序

### 階段一：基礎設定（優先級：高）
1. Task 3.1, 3.2, 3.3 - Docker 時區設定
2. Task 1.1, 1.2 - Docker 自動啟動機制
3. Task 4.1 - 服務啟動後立即開始倒數

### 階段二：自動執行功能（優先級：高）
4. Task 2.1, 2.2, 2.3 - 服務啟動後自動執行任務
5. Task 5.1 - 報告類型與通知類型釐清

### 階段三：通知功能改進（優先級：中）
6. Task 6.1, 6.2 - 收件者 Email 設定
7. Task 6.3 - 通知訊息顯示改進
8. Task 6.4 - Email 發送問題排查

---

## 5. 技術實作細節

### 5.1 狀態同步機制設計

#### 方案 A：共享狀態檔案（推薦）
- **優點**：簡單、快速、不需要額外服務
- **缺點**：需要處理檔案鎖定
- **實作**：
  - 使用 JSON 檔案儲存任務狀態
  - 使用檔案鎖定機制防止並發寫入
  - Web 服務定期讀取狀態檔案

#### 方案 B：資料庫記錄
- **優點**：持久化、支援查詢歷史
- **缺點**：需要修改資料庫結構
- **實作**：
  - 在資料庫中建立任務狀態表
  - scheduler 和 web_app 都寫入資料庫
  - Web 服務從資料庫讀取狀態

#### 方案 C：API 通訊
- **優點**：解耦、擴展性好
- **缺點**：需要額外的通訊機制
- **實作**：
  - scheduler 提供 HTTP API
  - web_app 透過 API 查詢狀態

**建議採用方案 A（共享狀態檔案）**，因為：
- 實作簡單
- 不需要額外的服務
- 效能好

### 5.2 啟動時自動執行流程

```
服務啟動
  ↓
檢查排程狀態
  ↓
排程狀態 = 啟動？
  ├─ 是 → 立即執行：
  │       1. 觸發全部（收集+分析）
  │       2. 生成 CISO 報告
  │       3. 更新狀態顯示
  │
  └─ 否 → 等待手動觸發
```

### 5.3 時區設定驗證

```python
# 驗證時區設定
import datetime
import pytz

# 檢查系統時區
print(datetime.datetime.now().astimezone())

# 檢查 APScheduler 時區
from apscheduler.schedulers.background import BackgroundScheduler
scheduler = BackgroundScheduler(timezone="Asia/Taipei")
print(scheduler.timezone)
```

---

## 6. 測試計劃

### 6.1 Docker 自動啟動測試
- [ ] 重啟電腦後，Docker 自動啟動
- [ ] Docker 啟動後，容器自動啟動
- [ ] 容器重啟後，服務自動恢復

### 6.2 服務啟動後自動執行測試
- [ ] 服務啟動後，自動執行收集+分析任務
- [ ] 服務啟動後，自動生成 CISO 報告
- [ ] 自動執行的任務狀態正確顯示

### 6.3 時區設定測試
- [ ] 容器內時區為 Asia/Taipei
- [ ] Python datetime 使用正確時區
- [ ] 排程器使用正確時區
- [ ] 報告時間戳記正確

### 6.4 下次執行時間測試
- [ ] 服務啟動後，倒數時間立即開始
- [ ] 倒數時間計算正確
- [ ] 倒數時間自動更新

### 6.5 通知功能測試
- [ ] 可以設定收件者 Email
- [ ] 設定正確保存
- [ ] 發送通知後顯示收件者 Email
- [ ] Email 成功發送

---

## 7. 風險評估

### 7.1 技術風險
- **風險 1**：狀態同步機制可能導致資料不一致
  - **緩解措施**：使用檔案鎖定機制，確保原子性操作
- **風險 2**：自動執行可能導致資源消耗過大
  - **緩解措施**：添加執行間隔檢查，防止頻繁執行

### 7.2 時程風險
- **風險 1**：Email 發送問題排查可能需要較長時間
  - **緩解措施**：先確認問題根源，再進行修復

---

## 8. 預估時間

### 總預估時間：約 18 小時

- **階段一**：約 4 小時
- **階段二**：約 7 小時
- **階段三**：約 7 小時

---

## 9. 後續維護

### 9.1 文檔更新
- 更新 README.md 中的啟動說明
- 更新 Docker 自動啟動說明
- 更新時區設定說明

### 9.2 監控與優化
- 監控自動執行任務的執行情況
- 監控 Email 發送成功率
- 收集使用者反饋

---

**計劃結束**

