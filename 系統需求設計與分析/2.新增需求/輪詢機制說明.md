# AETIM Web 界面輪詢機制說明

## 問題 1：每隔 2 秒 GET 一次，會不會太頻繁？

### 當前設定

根據 `templates/index.html` 的代碼：

```javascript
// 定期更新狀態（每 2 秒）
setInterval(updateStatus, 2000);  // 呼叫 /api/status

// 定期更新倒數時間（每 10 秒）
setInterval(updateCountdown, 10000);  // 呼叫 /api/scheduler/next-run
```

### 頻率分析

**當前輪詢頻率：**
- `/api/status`：每 **2 秒**一次（每分鐘 30 次）
- `/api/scheduler/next-run`：每 **10 秒**一次（每分鐘 6 次）

### 是否太頻繁？

**測試環境：**
- ✅ **可接受**：對於單一使用者或小團隊測試，每 2 秒的輪詢頻率是可接受的
- ✅ **即時性佳**：能提供較即時的狀態更新，適合監控任務執行狀態

**生產環境考量：**
- ⚠️ **資源消耗**：如果有多個使用者同時開啟頁面，會產生大量請求
- ⚠️ **伺服器負載**：頻繁的請求會增加伺服器負載（雖然單個請求很輕量）
- ⚠️ **網路流量**：雖然單個請求資料量小，但累積起來仍會產生一定流量

### 建議調整

**測試環境：**
- 保持 2 秒（即時性優先）

**生產環境：**
- 建議調整為 **5-10 秒**（平衡即時性和資源消耗）
- 如果有多個使用者，建議使用 **WebSocket** 或 **Server-Sent Events (SSE)** 實現推送更新

### 如何修改

可以修改 `templates/index.html` 中的輪詢間隔：

```javascript
// 修改前（每 2 秒）
setInterval(updateStatus, 2000);

// 修改後（每 5 秒）
setInterval(updateStatus, 5000);

// 或每 10 秒
setInterval(updateStatus, 10000);
```

---

## 問題 2：兩個紅色標記的請求有什麼不同？

### 請求對比

| 項目 | `/api/scheduler/next-run` | `/api/status` |
|------|---------------------------|---------------|
| **時間戳** | `11:41:54` | `11:42:00` |
| **API 端點** | `/api/scheduler/next-run` | `/api/status` |
| **功能** | 取得排程器「下次執行時間」和倒數計時 | 取得所有任務的「處理狀態」 |
| **輪詢頻率** | 每 10 秒一次 | 每 2 秒一次 |
| **回應內容** | `2`（日誌顯示異常，實際應為 JSON） | `200 -`（HTTP 200 成功） |
| **用途** | 更新「下次執行時間」倒數顯示 | 更新「處理狀態與報告」區塊的狀態 |

### 詳細說明

#### 1. `/api/scheduler/next-run`

**功能：**
- 計算並返回排程器的「下次執行時間」
- 計算倒數計時（還剩多少時間）
- 返回排程間隔設定

**回應格式：**
```json
{
  "success": true,
  "next_execution_time": "2025-11-07T12:00:00+08:00",
  "countdown_seconds": 3600,
  "countdown_str": "1小時 0分鐘 0秒",
  "interval_minutes": 240,
  "enabled": true
}
```

**日誌顯示 `2` 的原因：**
- 這可能是 Flask debug 模式的簡化輸出
- 實際回應是完整的 JSON，但日誌只顯示了部分資訊
- 這是正常的，不影響功能

#### 2. `/api/status`

**功能：**
- 返回所有任務的當前狀態
- 包括：收集任務、關聯分析、報告生成、通知發送

**回應格式：**
```json
{
  "success": true,
  "status": {
    "collectors": {
      "status": "idle",
      "message": "",
      "timestamp": null,
      "logs": []
    },
    "correlation": { ... },
    "report_generation": { ... },
    "notification": { ... }
  }
}
```

**日誌顯示 `200 -`：**
- `200` 是標準 HTTP 狀態碼（成功）
- `-` 表示沒有額外的回應訊息（這是 Flask 的標準日誌格式）

### 主要差異總結

1. **目的不同**：
   - `/api/scheduler/next-run`：專門用於排程器時間資訊
   - `/api/status`：用於所有任務的狀態資訊

2. **更新頻率不同**：
   - `/api/scheduler/next-run`：每 10 秒更新一次（時間變化較慢）
   - `/api/status`：每 2 秒更新一次（需要即時監控任務狀態）

3. **回應格式不同**：
   - `/api/scheduler/next-run`：返回時間相關資訊
   - `/api/status`：返回任務狀態字典

---

## 優化建議

### 1. 調整輪詢頻率

根據使用場景調整：

```javascript
// 測試環境：即時性優先
setInterval(updateStatus, 2000);        // 2 秒
setInterval(updateCountdown, 10000);   // 10 秒

// 生產環境：平衡效能和即時性
setInterval(updateStatus, 5000);       // 5 秒
setInterval(updateCountdown, 30000);   // 30 秒（時間變化慢，不需要太頻繁）

// 低負載環境：節省資源
setInterval(updateStatus, 10000);      // 10 秒
setInterval(updateCountdown, 60000);    // 60 秒
```

### 2. 動態調整頻率

可以根據任務狀態動態調整：

```javascript
// 當任務執行中時，更頻繁更新
// 當任務閒置時，降低更新頻率
```

### 3. 使用 WebSocket（進階）

對於生產環境，建議使用 WebSocket 實現推送更新，而不是輪詢：

- ✅ 減少不必要的請求
- ✅ 即時推送更新
- ✅ 降低伺服器負載
- ✅ 更好的使用者體驗

---

### 兩個紅色標記的請求有什麼不同？
#### 對比
|項目	|/api/scheduler/next-run	|/api/status|
|-|-|-|
|時間	|11:41:54	|11:42:00|
|功能	|取得「下次執行時間」和倒數計時|	取得所有任務的「處理狀態」|
|頻率	|每 10 秒一次|	每 2 秒一次|
|日誌回應	|2（Flask debug 簡化輸出）	|200 -（HTTP 200 成功）|

#### 詳細說明
##### **/api/scheduler/next-run**
- 用途：計算並返回排程器的「下次執行時間」和倒數計時
- 更新頻率：每 10 秒（時間變化較慢）
- 回應內容：時間資訊（下次執行時間、倒數秒數、倒數字串）
- 日誌顯示 2：Flask debug 模式的簡化輸出，實際回應為完整 JSON，不影響功能
##### **/api/status**
- 用途：返回所有任務的當前狀態（收集、分析、報告、通知）
- 更新頻率：每 2 秒（需要即時監控）
- 回應內容：任務狀態字典（status、message、timestamp、logs 等）
- 日誌顯示 200 -：標準 HTTP 200（成功），- 表示無額外訊息

#### 主要差異
- 目的不同：一個是時間資訊，一個是任務狀態
- 頻率不同：時間 10 秒，狀態 2 秒
- 資料量不同：狀態包含更多資訊

#### 總結
1. 輪詢頻率：
- 測試環境：2 秒可接受
- 生產環境：建議改為 5–10 秒
- 已優化為可配置常數，方便調整
2. 兩個 API 的差異：
- /api/scheduler/next-run：時間資訊，10 秒更新
- /api/status：任務狀態，2 秒更新
- 兩者功能不同，頻率不同，都是正常運作


**最後更新**：2025年11月7日

