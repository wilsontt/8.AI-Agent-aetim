##### 階段二：2.詳細設計
> 確認使用 Python 作為 AETIM 系統的技術架構。
> 現在，我將為您詳細規劃階段二：自動化收集與關聯分析 (Automation & Correlation) 的設計。這是 AETIM 系統的「引擎」與「大腦」。
> 此階段的目標是建立兩個核心 Python 模組：
> 1. 收集代理人 (Collection Agent)： 負責從階段 1.3 的情資來源獲取原始資料。
> 2. 關聯引擎 (Correlation Engine)： 負責過濾雜訊，將原始資料與您的資產清單比對，並評估風險。
--- 
1. 總體架構與技術棧 (Python Stack)
    - 執行環境： 一台專用的 Linux VM (或 Docker 容器)，安裝 Python 3.10+。
        - 核心函式庫 (Libraries)：
        - requests：用於所有 REST API 呼叫 (NVD, CISA)。
        - feedparser：用於解析 RSS feeds (VMware, MSRC)。
        - sqlite3：(或 SQLAlchemy + psycopg2/pyodbc) 用於儲存情資與資產。
        - pandas：用於高效能的記憶體內 (in-memory) 資產比對。
        - openai：(或 google-generativeai) 用於呼叫 LLM API，執行 AI 摘要任務。
        - APScheduler：(或 Crontab) 用於排程自動執行收集任務。
    - 資料庫設計： 我們將使用 SQLite (或您指定的公司資料庫) 建立三個關鍵表格：
        - T_Assets：您的資產清單 (從 CSV 匯入)。
        - T_Raw_Intel：從外部收集到的原始情資 (用於追蹤與避免重複)。
        - T_Validated_Threats：(本階段的關鍵產出) 已確認影響到內部資產的威脅。

2. 詳細設計：情資收集代理人 (Collection Agent)
這是一個 Python 應用程式，由多個「收集器」模組組成，並由一個主排程器 (scheduler.py) 驅動。

scheduler.py (主排程器)
- 使用 APScheduler 根據PIR的優先級設定不同的執行頻率。
- 排程範例：
    - P0 (緊急) - CISA KEV：每 1 小時執行一次 cisa_collector.py。
    - P1 (高) - NVD/Vendors：每 4 小時執行一次 nvd_collector.py 和 rss_collector.py。
    - P2 (中) - TWCERT (AI 任務)：每 6 小時執行一次 osint_collector.py。

cisa_collector.py (PIR-04, PIR-01)
- 功能： 獲取 CISA「已知遭利用漏洞(KEV)」列表。
- 邏輯：
    - 呼叫 CISA KEV 的 JSON API。
    - 檢查 dateAdded 是否為新的。
    - 將新漏洞 (CVE-ID, 產品名稱) 存入 T_Raw_Intel 資料庫。

nvd_collector.py (PIR-01, PIR-02, PIR-03)
- 功能： 根據資產清單，主動查詢 NVD。
- 邏輯：
    - 從 T_Assets 讀取關鍵字 (例如: VMware ESXi, Microsoft SQL Server 2017)。
    - 使用 NVD API 2.0，查詢過去 24 小時內與這些關鍵字相關的新 CVEs。
    - 將返回的 CVEs (含 CVSS 分數、CPE 資訊) 存入 T_Raw_Intel。

rss_collector.py (PIR-02, PIR-03)
- 功能： 監控 VMware 和 Microsoft 的安全通報。
- 邏輯：
    - 使用 feedparser 讀取 VMware VMSA 和 MSRC 的 RSS feed。
    - 檢查 guid (唯一標識符) 是否已存在 T_Raw_Intel 中。
    - 若為新條目，存入 T_Raw_Intel。

osint_collector.py (PIR-05) - (AI 應用核心)
- 功能： 收集並「理解」TWCERT/CC 的中文通報。
- 邏輯：
    - 爬取 TWCERT/CC 網站或監控 Email (依您選擇的管道)。
    - 獲取新的通報原文 (非結構化中文文字)。
    - (AI 介入) 呼叫 LLM API (例如 GPT-4o 或 Gemini Pro)，並下達指令 (Prompt)：
        - "你是一位頂尖資安威脅分析師。請閱讀以下 TWCERT 通報，並以 JSON 格式回傳：
        - summary: 50 字的中文威脅摘要。
        - affected_products: 受影響的產品列表。
        - cves: 提及的 CVE 編號列表 (若有)。
        - iocs: 提取所有 IP、Domain、File Hash。 [通報原文貼於此]"
    - 將 LLM 回傳的結構化 JSON 存入 T_Raw_Intel。

--- 

3. 詳細設計：關聯與風險評分引擎 (Correlation Engine)
這是本階段的「大腦」。它會在「收集代理人」完成任務後被觸發執行。
correlation_engine.py
    - 功能： 比對原始情資與內部資產，並計算風險。
    - 邏輯 (Step-by-Step)：
        - 載入資產： df_assets = pd.read_sql("SELECT * FROM T_Assets", db_connection)。將資產載入- 為 Pandas DataFrame 以便快速比對。
        - 提取新情資： 從 T_Raw_Intel 提取所有 Status = 'New' 的情資。
        - 迭代比對 (The Loop)：
          - for intel in new_intel_list:
          - is_match = False
          - matched_asset_list = []
          - (比對邏輯 A：CVE 比對)
            - 如果 intel.type == 'CVE' (來自 CISA, NVD, RSS)：
            - FOR 每一筆資產 (asset in df_assets.itertuples()):
              - // 執行模糊與精確字串比對
              - IF (intel.product_name.lower() in asset.Applications.lower()) OR (intel.product_name.lower() in asset.OS.lower())
              - // 例如：intel.product="Windows Server 2008 R2" asset.OS="Windows Server 2008 R2 Service Pack 1" -> MATCH!
              - is_match = True
              - matched_asset_list.append(asset.ID)
          - (比對邏輯 B：IOC 比對)
            - 如果 intel.type == 'IOC_Report' (來自 AI 處理的 TWCERT)：
            - FOR ip in intel.iocs.ips:
              - // 檢查是否為對外主機的 IP
              - IF ip in df_assets[df_assets.Is_Public == 'Y'].IP.values:
              - is_match = True
              - // 這裡應觸發更高警報 (外部 IOC 命中對外資產)
4. 風險評分 (Scoring)：
   - if is_match:
     - FOR asset_id in matched_asset_list:
       - asset = df_assets.find(asset_id)
       - base_score = intel.cvss_score (若有) or 7.0 (若無)
       - // 套用PIR的客製化加權 (關鍵!)
       - if asset.Is_Public == 'Y': base_score *= 1.5
       - if asset.Criticality == '高': base_score *= 1.3
       - if intel.source == 'CISA_KEV': base_score *= 2.0
       - if "2008" in asset.OS: base_score *= 1.2
       - final_score = min(10.0, base_score) // 滿分 10 分
       - // 產出至已驗證威脅資料庫
       - db.execute("INSERT INTO T_Validated_Threats (intel_id, asset_id, risk_score, status) VALUES (?, ?, ?, 'New')", ...)
   - else:
     - db.execute("UPDATE T_Raw_Intel SET Status = 'Logged (No Match)' WHERE id = ?', intel.id) // 噪音過濾

--- 

###### 階段二產出 (交付至階段三)
當 correlation_engine.py 執行完畢後，我們將得到：
1. T_Validated_Threats (已驗證威脅資料庫)： 一個清晰的列表，包含 哪一條情資 影響了 哪一台主機，以及其 客製化的風險分數。
2. 觸發器 (Triggers)： 引擎在計算出 final_score 後，將立即觸發階段三 (報告與通知)。

階段二的設計已完成。這套 Python 腳本將自動為您完成「收集」與「分析比對」的繁重工作。


